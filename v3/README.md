# V3 - SaaS MVP (모듈화 + 워커 분리)

## 프로젝트 개요

V2 셀러앱을 SaaS화하기 위한 MVP 버전입니다. 코드 관리성을 위한 모듈 분리와 트래픽 급증에 대비한 워커 분리 구조로 설계했습니다.

## 기술적 의사결정

### 프론트엔드: CSR + Vue SPA 도입

#### SSR vs CSR 선택
웹앱 특성상 SEO의 중요성이 크게 필요하지 않았고, 트래픽을 줄이고 프론트와 백엔드의 로직 분리를 통한 구조적 명확성을 가지고자 **CSR**을 선택했습니다.

#### 기술 스택 전환
- **AS-IS**: Pure JavaScript + CSS + HTML
- **TO-BE**: Vue 기반 SPA

개발을 진행하면서 디자인의 통일감 부족과 컴포넌트의 필요성을 깨닫게 되었습니다. 다만 일일히 컴포넌트를 만드는 것은 부담이 되어, **v3.1 업데이트**를 통해 **Element Plus** 컴포넌트 프레임워크를 도입했습니다.

**도입 결과:**
- 페이지당 코드량 약 **30% 감소**
- 디자인이 큰 폭으로 정돈됨
- 프론트엔드 기본 설계 구조에 대한 이해 향상

### 백엔드: 아키텍처 설계와 시행착오

#### 초기 설계: 모듈화된 레이어드 아키텍처
기존 레이어드 아키텍처의 문제점(파일 간 거리, 이동의 불편성, 복잡한 의존관계)을 해소하고자 **1단계 모듈 단위 분리** → **2단계 레이어 분리**를 진행했습니다.

#### 발생한 문제점들

**문제점 1: 잘못된 도메인 분리**
- **원인**: 유저플로우를 도메인으로 잘못 생각
- **예시**: 게임으로 비유하면 '레벨 시스템, 체력 시스템, 모션 시스템' 대신 '게임 초반/중반/후반'으로 나눈 것과 같음
- **결과**: 상태관리의 책임이 분산되어 기술부채 급증

**임시 해결책:**
- DB 계층과 프론트엔드에서 유저플로우와 도메인을 최대한 묶음
- 중앙컨트롤 테이블을 통해 큐-워커 패턴으로 구현
- UX 하락은 있지만 코드 안정성을 우선시

**🚨 문제점 2: 데이터 재사용성 부족**
- **원인**: 데이터를 한 번 쓰고 버리는 구조
- **결과**: DB에서 데이터를 계속 요청하며 높은 부하 발생

**해결책:**
- Redis는 단일 서버 환경에서 오버엔지니어링이라 판단
- **Map 기반 인메모리 캐시** 도입으로 순차적 개선

**🚨 문제점 3: API 관리 이슈**
- 지속적인 리팩토링으로 의도치 않은 API 양식 변형
- 문서화 누락 발생

## 아키텍처 설계

### 1차 분리: 모듈 단위 분리 (논리적)
```
┌─────────────────────────────────────────────────────────────────────────────────────
│                                단일 애플리케이션                                       │ 
├──────────┬──────────┬──────────┬──────────┬──────────┬──────────┬───────────────────
│ 세팅모듈  │Auth모듈   │ 소싱모듈  │ 가공모듈  │후가공모듈  │ 등록모듈   │     등록후모듈     │ │(Settings)│ (Auth)   │(Sourcing)│Processing│Post-Proc │Register  │   Post-Register   │
│          │          │          │          │          │          │                   │
│• DB 중계  │• 인증처리 │•데이터수집│ •데이터변환│•후처리작업 │•네이버등록 │• 등록 후관리작업   │
│• 설정관리  │• DB 중계 │• 외부API │ •비즈로직  │•검증/보완 │• API 연동 │• 상태 업데이트        
└──────────┴──────────┴──────────┴──────────┴──────────┴──────────┴──────────────────────┘
```

### 2차 분리: 레이어드 아키텍처 (각 모듈 내부)
```
┌─────────────────────────────────────────────────────────┐
│                    라우터 레이어                         │
│                 (Controller Layer)                      │
├─────────────────────────────────────────────────────────┤
│                    서비스 레이어                         │
│                  (Service Layer)                        │
├─────────────────────────────────────────────────────────┤
│                  리포지토리 레이어                       │
│                (Repository Layer)                       │
└─────────────────────────────────────────────────────────┘
```

### 3차 분리: 워커 시스템 (트래픽 방어)
```
┌─────────────────┐    Redis Queue    ┌─────────────────┐
│   메인 서버      │ ──────────────── │   별도 워커들    │
│                 │                  │                  │
│ • 빠른 응답 유지 │                  │ • 무거운 작업    │
│ • 요청 큐 적재   │                  │ • 시간 소모 작업 │
│ • DB 중계       │                  │ • 외부 API 호출  │
│ • 결과 반환     │                  │ • GPU 연산       │
└─────────────────┘                  └─────────────────┘
```

## 성공적인 개선사항

### ✅ 잘한 점 1: 트래픽 제어
- **Redis 기반 프로듀서-컨슈머(큐-워커) 패턴** 도입
- 외부 서비스, 복잡한 서비스 로직, Rate Limit이 있는 연동 서비스에 적용
- 스파이크 트래픽에 대한 제어권 확보
- 큐에 대한 백프레셔(Backpressure) 구현

### ✅ 잘한 점 2: 서버 부담 경감
- 가능한 몇몇 기능을 **Stateless**하게 구현
- 서버의 관리 책임 감소

## 기술 스택

- **프론트엔드**: Vue.js SPA + Element Plus
- **백엔드**: 모듈화된 모놀리식 + 워커 분리 node.js + express + python 
- **큐 시스템**: Redis
- **캐시**: Map 기반 인메모리 캐시
- **데이터베이스**: MySQL


## 모듈 구성

### 메인 애플리케이션
- **세팅 모듈**: 사용자 설정 관리 (DB 중계 위주)
- **Auth 모듈**: 인증 처리 (DB 중계 위주)  
- **소싱 모듈**: 상품 데이터 수집 및 외부 API 연동
- **가공 모듈**: 데이터 변환 및 비즈니스 로직 처리
- **후가공 모듈**: 후처리 작업 및 데이터 검증/보완
- **등록 모듈**: 네이버 등록 및 API 연동
- **등록후 모듈**: 등록 후 관리 작업 및 상태 업데이트

### 워커 시스템
- [**이미지 번역 파이프라인**](../v3_image_translator/README.md) - GPU 연산 워커 (Archived)


## 개발 후기 및 학습 내용

**핵심 깨달음**: 왜 사람들이 그렇게 DDD, 객체지향을 강조했는지 감을 잡을 수 있는 프로젝트였습니다.

도메인 설계의 중요성과 상태 관리의 복잡성을 몸소 체험하며, 좋은 아키텍처의 필요성을 절실히 느꼈습니다.

## V4 개선 계획

- **DDD와 적절한 추상화**를 통한 설계-> 응집도 높이기
- **5Layer 아키텍처**: Validator 계층 도입으로 주요 3계층(Repo/Service/Controller) 간의 결합도 감소
- 상태 관리 책임의 명확화
- 캐시 히트를 통한 서버 부담 경감

## 버전 로그

- **v3.0**: 기능 구현 완성
- **v3.1**: Element Plus 컴포넌트 프레임워크 도입으로 디자인 통일감 확보
- **v3.2**: 이미지 번역 파이프라인 개선(7워커->2워커, 워커 내부 파이프라인 최적화)

## 한계

- 실제 대규모 트래픽 검증 부족
- 도메인 분리 설계 미숙으로 인한 기술부채 발생

---

*V2의 SaaS 전환 가능성을 검증하고, 실제 개발 과정에서의 시행착오를 통해 아키텍처 설계의 중요성을 학습한 프로젝트*
